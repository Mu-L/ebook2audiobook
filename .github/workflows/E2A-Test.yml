name: E2A Test

on:
  workflow_dispatch:
    inputs:
      wipeAndReinstall:
        type: boolean
        description: 'Wipe & Re-Install E2A'

  pull_request:
    branches:
      - main
    types:
      - opened
      - synchronize
      - reopened
    paths-ignore:
      - CODE_OF_CONDUCT.md
      - LICENSE
      - README.md
      - readme/**
      - dockerfiles/**
      - Notebooks/**
      - .github/workflows/stale.yml
      - .github/workflows/custom-command.yml

  push:
    branches:
      - main
    paths-ignore:
      - CODE_OF_CONDUCT.md
      - LICENSE
      - README.md
      - readme/**
      - dockerfiles/**
      - Notebooks/**
      - .github/workflows/stale.yml
      - .github/workflows/custom-command.yml

  release:
    types:
      - published

jobs:
  E2A-test:
    strategy:
      fail-fast: false
      matrix:
        #  windows and linux can be added to the matrix when good runners for those are made available for this repo
        os: [macos]
    runs-on: [self-hosted, "${{ matrix.os }}"]
    
    steps:
      - name: Print runner info
        shell: bash
        run: |
          echo "Running on:"
          uname -a
          if [[ "$OSTYPE" == "darwin"* ]]; then 
            sw_vers
          elif [[ -f /etc/os-release ]]; then
            cat /etc/os-release
          else
            echo "Windows / Other OS detected"
          fi

      # NEW STEP: Determine which command to run based on OS
      - name: Determine OS and Script Command
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows" ]]; then
            echo "Detecting Windows. Using ebook2audiobook.cmd"
            # We use 'cmd //c' to run a batch file from Git Bash
            echo "RUN_CMD=cmd //c ebook2audiobook.cmd" >> $GITHUB_ENV
            echo "IS_WINDOWS=true" >> $GITHUB_ENV
          else
            echo "Detecting Unix. Using ebook2audiobook.command"
            echo "RUN_CMD=./ebook2audiobook.command" >> $GITHUB_ENV
            echo "IS_WINDOWS=false" >> $GITHUB_ENV
          fi

      - name: Wipe & Re-Install E2A
        if: ${{ inputs.wipeAndReinstall }}
        shell: bash
        run: rm -rf ~/ebook2audiobook

      - name: Clone ebook2audiobook
        shell: bash
        run: |
          set -e
       
          REPO_DIR=~/ebook2audiobook
          REPO_URL="https://github.com/${{ github.repository }}"
          IS_PR="${{ github.event_name == 'pull_request' }}"
          BASE_REF="${{ github.event.pull_request.base.ref }}"
          HEAD_REF="${{ github.event.pull_request.head.ref }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          HEAD_REPO_URL="${{ github.event.pull_request.head.repo.clone_url }}"
          TRIGGER_SHA="${{ github.sha }}"
          FRESH_CLONE=0
       
          echo "==> Event: ${{ github.event_name }}"
          echo "==> Repo: $REPO_URL"
       
          # Clone or reuse
          if [ -d "$REPO_DIR" ]; then
            echo "==> Reusing existing repo"
            cd "$REPO_DIR"
            # Set correct remote and fix ambiguous refs
            git remote set-url origin "$REPO_URL"
            git remote set-head origin -a
            git remote prune origin
            git fetch --all --prune
       
            echo "==> Cleaning working directory"
            git reset --hard
          else
            echo "==> Cloning fresh"
            git clone "$REPO_URL" "$REPO_DIR"
            cd "$REPO_DIR"
            git remote set-head origin -a
            git remote prune origin
            git fetch --all --prune
            FRESH_CLONE=1
          fi
       
          if [ "$IS_PR" = "true" ]; then
            echo "==> PR detected: simulating GitHub merge (base: $BASE_REF ← head: $HEAD_REF)"
       
            # Fetch both branches. For the head, we must fetch from the actual source repo (fork)
            # because 'origin' might not have the fork's branch.
            git fetch origin "$BASE_REF":"origin/$BASE_REF"
            
            if [ -n "$HEAD_REPO_URL" ]; then
              echo "==> Fetching head from fork: $HEAD_REPO_URL"
              git fetch "$HEAD_REPO_URL" "$HEAD_REF":refs/remotes/origin/$HEAD_REF
            else
              # Fallback (shouldn't happen for PRs)
              git fetch origin "$HEAD_REF":"origin/$HEAD_REF"
            fi
       
            # Reset to base branch
            git checkout -B "$BASE_REF" "remotes/origin/$BASE_REF"
            git reset --hard "origin/$BASE_REF"
       
            # Merge PR source
            if ! git merge --no-ff --no-edit "origin/$HEAD_REF"; then
              echo "❌ Merge conflict simulating PR merge"
              echo "❌ Initial merge failed, attempting cleanup of __pycache__ and retry..."

              # Remove known __pycache__ dirs that may cause conflict
              echo "==> Cleaning up untracked files like __pycache__"
              git clean -ffd lib/

              # Retry the merge
              if ! git merge --no-ff --no-edit "origin/$HEAD_REF"; then
                echo "❌ Merge still failed after cleanup"
                exit 1
              fi
            fi
          else
            echo "==> Not a PR: checking out triggered commit directly"
            git fetch origin "$TRIGGER_SHA"
            git checkout --detach "$TRIGGER_SHA"
            git reset --hard "$TRIGGER_SHA"
          fi
       
          echo "==> Final repo state:"
          git status
          git log -1 --oneline
       
          if [ "$FRESH_CLONE" -eq 1 ]; then
            echo "==> Running Help Check to verify install"
            
            # Use the dynamic command variable
            if ! $RUN_CMD --help; then
              echo "==> Attempting fallback with conda deactivation (Unix only)"
              if [ "$IS_WINDOWS" != "true" ]; then
                  source "$(conda info --base 2>/dev/null)/etc/profile.d/conda.sh" 2>/dev/null && conda deactivate || true
              fi
              $RUN_CMD --help
            fi
          else
            echo "==> Skipping script run because repo already existed"
          fi

      - name: Create Audiobook Output folders for Artifacts
        shell: bash
        run: |
          mkdir -p ~/ebook2audiobook/audiobooks/{TACOTRON2,FAIRSEQ,UnFAIRSEQ,VITS,YOURTTS,XTTSv2,XTTSv2FineTune,XTTSv2FineTuneCustom,BARK}
          find ~/ebook2audiobook/audiobooks/{TACOTRON2,FAIRSEQ,UnFAIRSEQ,VITS,YOURTTS,XTTSv2,XTTSv2FineTune,XTTSv2FineTuneCustom,BARK} -mindepth 1 -exec rm -rf {} +

      # This step only runs on non-windows because we don't need to modify the .command file if we are running .cmd
      - name: Add set -e at beginning of ebook2audiobook.command (for error passing)
        if: matrix.os != 'windows'
        shell: bash
        run: |
          cd ~/ebook2audiobook
          conda deactivate 2>/dev/null || true
          sed -i.bak '1s;^;set -e\n;' ebook2audiobook.command && rm -f ebook2audiobook.command.bak

      - name: English TACOTRON2 Custom-Voice headless single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi
          
          $RUN_CMD --headless  --language eng --ebook "tools/workflow-testing/test1.txt" --tts_engine TACOTRON2 --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/TACOTRON2

      - name: English FAIRSEQ OCR headless single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language eng --ebook "tools/workflow-testing/ocr_eng_script_font.jpg" --tts_engine FAIRSEQ --output_dir ~/ebook2audiobook/audiobooks/FAIRSEQ

      - name: Haitian Creole FAIRSEQ OCR headless single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language hat --ebook "tools/workflow-testing/odc_test_haitian.pdf" --tts_engine FAIRSEQ --output_dir ~/ebook2audiobook/audiobooks/FAIRSEQ

      - name: English FAIRSEQ Custom-Voice headless single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language eng --ebook "tools/workflow-testing/test1.txt" --tts_engine FAIRSEQ --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/FAIRSEQ
       
      - name: Unusual FAIRSEQ Custom-Voice headless single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language urd-script_devanagari --ebook "tools/workflow-testing/urd-script_davanagari-test.txt" --tts_engine FAIRSEQ --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/UnFAIRSEQ

      - name: English VITS Custom-Voice headless single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language eng --ebook "tools/workflow-testing/test1.txt" --tts_engine VITS --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/VITS

      - name: Hungarian VITS Custom-Voice headless single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language hun --ebook "tools/workflow-testing/hun-test.txt" --tts_engine VITS --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/VITS

      - name: English YOURTTS Custom-Voice headless batch test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language eng --ebooks_dir "tools/workflow-testing" --tts_engine YOURTTS --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/YOURTTS

      - name: Default XTTSv2 headless Custom-Voice single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language eng --ebook "tools/workflow-testing/test1.txt" --tts_engine XTTSv2 --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/XTTSv2

      - name: Hungarian XTTSv2 headless Custom-Voice single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language hun --ebook "tools/workflow-testing/hun-test.txt" --tts_engine XTTSv2 --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/XTTSv2


      - name: English XTTSv2 headless fine-tuned XTTSv2 model single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless  --language eng --ebook "tools/workflow-testing/test1.txt" --tts_engine XTTSv2 --fine_tuned AiExplained --output_dir ~/ebook2audiobook/audiobooks/XTTSv2FineTune

      - name: English XTTSv2 headless custom fine-tuned XTTSv2 model single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          [ ! -f BadCartmanSouthPark.zip ] && curl -L "https://huggingface.co/drewThomasson/fineTunedTTSModels/resolve/main/xtts-v2/eng/BadCartmanSouthPark/BadCartmanSouthPark.zip" -o BadCartmanSouthPark.zip || echo "BadCartmanSouthPark.zip already exists"
          
          $RUN_CMD --headless --language eng --ebook "tools/workflow-testing/test1.txt" --custom_model "BadCartmanSouthPark.zip" --tts_engine XTTSv2 --output_dir ~/ebook2audiobook/audiobooks/XTTSv2FineTuneCustom
          
          # Clean up sessions, careful with path on windows, but rm -rf works in git bash
          ls -lhR ./models/__sessions || true
          rm -rf ./models/__sessions

      - name: English BARK Custom-Voice headless single test
        shell: bash
        run: |
          cd ~/ebook2audiobook
          if [ "$IS_WINDOWS" != "true" ]; then conda deactivate 2>/dev/null || true; fi

          $RUN_CMD --headless --language eng --ebook "tools/workflow-testing/test1.txt" --tts_engine BARK --voice "voices/eng/elder/male/DavidAttenborough.wav" --output_dir ~/ebook2audiobook/audiobooks/BARK 

      - name: Upload audiobooks folder artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: audiobooks-${{ matrix.os }}
          path: ~/ebook2audiobook/audiobooks
